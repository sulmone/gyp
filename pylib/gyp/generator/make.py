#!/usr/bin/python


# Skeleton for generating Makefiles from .gyp files.
#
# THIS DOES NOT WORK RIGHT NOW (2 February 2009), but is being checked in
# to capture current progress and provide a head start for next step(s)
# for possibly finishing it off.
#
#
# This would need some polishing (a fair amount?) to stitch into the Chrome
# build.  That said, here is a starter list of things that would need to be
# decided to create a "good" Makefile infrastructure for building Chromium:
#
# * Decide on a model for use of the .mk files.  The code below
#   generates a separate .mk file for each target.
#   
#   This may be too fine-grained and might be better implemented as a
#   .mk file per .gyp file, with multiple targets therein.  If so, then
#   the variables in the generated Makefile need to be differentiated so
#   that the lists of source files are named (for example) $(base_SRCS),
#   $(base_gfx_SRCS) instead of just one $(SRCS) variable in the Make
#   global namespace.
#
# * Decide how to stitch the separate .mk files into a coherent Make-based
#   build would need to be decided.  They could all be included into a
#   single-DAG build, but then that (again) requires figuring out how to
#   split up the variable namespace so different .mk files don't stomp
#   on each others' values.
#
#   Stiching them together through recursive Make invocation begs the
#   question of whether the invocations should reflect the project
#   dependencies (i.e., should *every* component that uses icu38 call
#   icu38.mk to make sure it's up to date?  obviously not) and how.  Again,
#   solvable, but it should be solved in a way that works for Chromium.
#
# * Decide how global settings are maintained and/or imported.  We have
#   no current analog in Makefile-land for the .xcconfig and .vsprops
#   files.  One would have to be created, or else we wait (?) until
#   all of the settings are defined in the .gyp hierarchy and everything
#   is expanded in-line.
#
# * Dependencies.  The XCode and Visual Studio do the dependency analysis
#   among the source files basically for free.  Make doesn't.  The code
#   below tries to do this cheaply by adding a "make depend" target
#   to the generated makefiles and using it to call the "makedepend"
#   program to generate the dependencies.  However, it doesn't work now:
#   I tracked it down missing /usr/include/linux and /usr/include/c++/4.2
#   before deciding not to pull on that thread anymore right now.
#
#   One possible solution, of course, is to use gcc -MMD and include the
#   .d files.  That takes care of most dependencies, but isn't a general
#   solution for other files not generated by gcc (resource files,
#   packaging, etc.).


import gyp
#import gyp.makefile as makefile
import os.path
import subprocess
import re
import sys


generator_default_variables = {
  'OS': 'linux',
}

header = """\
# This file is generated; do not edit.

EOL :=
"""

footer = """\
MAKEFILE := $(lastword $(MAKEFILE_LIST))

depend:
\tmakedepend -f$(MAKEFILE) -- $(CFLAGS) -- $(SRCS)
"""

def WriteList(fp, list, prefix='',
                        separator=' \\\n\t',
                        preamble=None,
                        postamble=' \\\n\t$(EOL)\n'):
  if list:
    fp.write(preamble or '')
    fp.write((separator or ' ').join([prefix + l for l in list]))
    fp.write(postamble or '')


def GenerateMakefile(output_filename, build_file, spec):
  print 'Generating %s' % output_filename

  fp = open(output_filename, 'w')

  fp.write(header)

  defines = spec.get('defines')
  WriteList(fp, defines, prefix='-D', preamble='\nDEFS := \\\n\t')

  include_dirs = spec.get('include_dirs')
  WriteList(fp, include_dirs, prefix='-I', preamble='\nINCS := \\\n\t')

  libraries = spec.get('libraries')
  WriteList(fp, libraries, prefix='-l', preamble='\nLIBS := \\\n\t')

  sources = spec['sources']
  if sources:
    WriteList(fp, sources, preamble='\nSRCS := \\\n\t')
    fp.write('\nCPPFILES := $(filter %.cpp,$(SRCS))\n')
    fp.write('\nOBJS := $(CPPFILES:.cpp=.o)\n')
    fp.write('\nCFLAGS := $(DEFS) $(INCS)\n')
    fp.write('CXXFLAGS := $(DEFS) $(INCS)\n')

  t = spec.get('type')
  if not t in (None, 'none'):
    target = {
                  'executable' : spec['target_name'],
                  'static_library' : 'lib%s.a' % spec['target_name'],
              }[t]
    fp.write('\n')
    fp.write('%s: $(OBJS)\n' % target)

  fp.write('\n')
  fp.write(footer)
  fp.write('\n')

  fp.close()

def GenerateOutput(target_list, target_dicts, data):
  for build_file, build_file_dict in data.iteritems():
    if not build_file.endswith('.gyp'):
      # TODO(mark): Pick an exception class
      raise 'Build file name must end in .gyp'

  for qualified_target in target_list:
    [build_file, target] = gyp.BuildFileAndTarget('', qualified_target)[0:2]
    if target_list > 1:
      output_file = os.path.join(os.path.split(build_file)[0],
                                 target + '_gyp.mk')
    else:
      output_file = os.path.abspath(build_file[:-4] + '_gyp.mk')
    GenerateMakefile(output_file, build_file, target_dicts[qualified_target])

    # TODO:  make automatically generating the dependencies
    # configurable from the command line?
    # Have makedepend (called through the makefile itself) add the dependencies.
    subprocess.call(['make', '-f', output_file, 'depend'])

    # TODO:  make removing makedepend's .bak file
    # configurable from the command line?
    try:
      os.unlink(output_file + '.bak')
    except EnvironmentError:
      pass
