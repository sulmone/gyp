#!/usr/bin/python

"""Xcode project file generator.

This module is both an Xcode project file generator and a documentation of the
Xcode project file format.  Knowledge of the project file format was gained
based on extensive experience with Xcode, and by making changes to projects in
Xcode.app and observing the resultant changes in the associated project files.

XCODE PROJECT FILES

The generator targets the file format as written by Xcode 3.1 (specifically,
3.1.2), but past experience has taught that the format has not changed
significantly in the past several years, and future versions of Xcode are able
to read older project files.

Xcode project files are "bundled": the project "file" from an end-user's
perspective is actually a directory with an ".xcodeproj" extension.  The
project file from this module's perspective is actually a file inside this
directory, always named "project.pbxproj".  This file contains a complete
description of the project and is all that is needed to use the xcodeproj.
Other files contained in the xcodeproj directory are simply used to store
per-user settings, such as the state of various UI elements in the Xcode
application.

The project.pbxproj file is a property list, stored in a format almost
identical to the NeXTstep property list format.  The file is able to carry
Unicode data, and is encoded in UTF-8.  The root element in the property list
is a dictionary that contains several properties of minimal interest, and two
properties of immense interest.  The most important property is a dictionary
named "objects".  The entire structure of the project is represented by the
children of this property.  The objects dictionary is keyed by unique 96-bit
values represented by 24 uppercase hexadecimal characters.  Each value in the
objects dictionary is itself a dictionary, describing an individual object.

Each object in the dictionary is a member of a class, which is identified by
the "isa" property of each object.  A variety of classes are represented in a
project file.  Objects can refer to other objects by ID, using the 24-character
hexadecimal object key.  A project's objects form a tree, with a root object
of class PBXProject at the root.  As an example, the PBXProject object serves
as parent to an XCConfigurationList object defining the build configurations
used in the project, a PBXGroup object serving as a container for all files
referenced in the project, and a list of target objects, each of which defines
a target in the project.  There are several different types of target object,
such as PBXNativeTarget and PBXAggregateTarget.  In this module, this
relationship is expressed by having each target type derive from an abstract
base named XCTarget.

The project.pbxproj file's root dictionary also contains a property, sibling to
the "objects" dictionary, named "rootObject".  The value of rootObject is a
24-character object key referring to the root PBXProject object in the
objects dictionary.

In Xcode, every file used as input to a target or produced as a final product
of a target must appear somewhere in the hierarchy rooted at the PBXGroup
object referenced by the PBXProject's mainGroup property.  A PBXGroup is
generally represented as a folder in the Xcode application.  PBXGroups can
contain other PBXGroups as well as PBXFileReferences, which are pointers to
actual files.

Each XCTarget contains a list of build phases, represented in this module by
the abstract base XCBuildPhase.  Examples of concrete XCBuildPhase derivations
are PBXSourcesBuildPhase and PBXFrameworksBuildPhase, which correspond to the
"Compile Sources" and "Link Binary With Libraries" phases displayed in the
Xcode application.  Files used as input to these phases (for example, source
files in the former case and libraries and frameworks in the latter) are
represented by PBXBuildFile objects, referenced by elements of "files" lists
in XCTarget objects.  Each PBXBuildFile object refers to a PBXBuildFile
object as a "weak" reference: it does not "own" the PBXBuildFile, which is
owned by the root object's mainGroup or a descendant group.  In most cases, the
layer of indirection between an XCBuildPhase and a PBXFileReference via a
PBXBuildFile appears extraneous, but there's actually one reason for this:
file-specific compiler flags are added to the PBXBuildFile object so as to
allow a single file to be a member of multiple targets while having distinct
compiler flags for each.  These flags can be modified in the Xcode applciation
in the "Build" tab of a File Info window.

When a project is open in the Xcode application, Xcode will rewrite it.  As
such, this module is careful to adhere to the formatting used by Xcode, to
avoid insignificant changes appearing in the file when it is used in the
Xcode application.  This will keep version control repositories happy, and
makes it possible to compare a project file used in Xcode to one generated by
this module to determine if any significant changes were made in the
application.

Xcode has its own way of assigning 24-character identifiers to each object,
which is not duplicated here.  Because the identifier only is only generated
once, when an object is created, and is then left unchanged, there is no need
to attempt to duplicate Xcode's behavior in this area.  The generator is free
to select any identifier, even at random, to refer to the objects it creates,
and Xcode will retain those identifiers and use them when subsequently
rewriting the project file.  However, the generator would choose new random
identifiers each time the project files are generated, leading to difficulties
comparing "used" project files to "pristine" ones produced by this module,
and causing the appearance of changes as every object identifier is changed
when updated projects are checked in to a version control repository.  To
mitigate this problem, this module chooses identifiers in a more deterministic
way, by hashing a description of each object as well as its parent and ancestor
objects.  This strategy should result in minimal "shift" in IDs as successive
generations of project files are produced.

THIS MODULE

This module introduces several classes, all derived from the XCObject class.
Nearly all of the "brains" are built into the XCObject class, which understands
how to create and modify objects, maintain the proper tree structure, compute
identifiers, and print objects.  For the most part, classes derived from
XCObject need only provide a _schema class object, a dictionary that
expresses what properties objects of the class may contain.

Given this structure, it's possible to build a minimal project file by creating
objects of the appropriate types and making the proper connections:

  config_list = XCConfigurationList()
  group = PBXGroup()
  project = PBXProject({"buildConfigurationList": config_list,
                        "mainGroup": group})

With the project object set up, it can be added to an XCProjectFile object.
XCProjectFile is a pseudo-class in the sense that it is a concrete XCObject
subclass that does not actually correspond to a class type found in a project
file.  Rather, it is used to represent the project file's root dictionary.
Printing an XCProjectFile will print the entire project file, including the
full "objects" dictionary.

  project_file = XCProjectFile({"rootObject": project})
  project_file.ComputeIDs()
  project_file.Print()
"""

import hashlib
import string
import sys


def StringContainsOnly(s, chars):
  """Returns True if s does not contain any character other than those in
  chars."""

  for c in s:
    if chars.find(c) == -1:
      return False
  return True


class XCObject(object):
  """The abstract base of all class types used in Xcode project files.

  Class variables:
    _schema: A dictionary defining the properties of this class.  The keys to
             _schema are string property keys as used in project files.  Values
             are a list of four or five elements:
             [ is_list, property_type, is_strong, is_required, default ]
             is_list: True if the property described is a list, as opposed
                      to a single element.
             property_type: The type to use as the value of the property,
                            or if is_list is True, the type to use for each
                            element of the value's list.  property_type must
                            be an XCObject subclass, or one of the built-in
                            types str, int, or dict.
             is_strong: If property_type is an XCObject subclass, is_strong
                        is True to assert that this class "owns," or serves
                        as parent, to the property value (or, if is_list is
                        True, values).  is_strong must be False if
                        property_type is not an XCObject subclass.
             is_required: True if the property is required for the class.
                          Note that is_required being True does not preclude
                          an empty string ("", in the case of property_type
                          str) or list ([], in the case of is_list True) from
                          being set for the property.
             default: Optional.  If is_requried is True, default may be set
                      to provide a default value for objects that do not supply
                      their own value.  If is_required is True and default
                      is not provided, users of the class must supply their own
                      value for the property.
             Note that although the values of the array are expressed in
             boolean terms, subclasses provide values as integers to conserve
             horizontal space.
    _should_print_single_line: False in XCObject.  Subclasses whose objects
                               should be written to the project file in the
                               alternate single-line format, such as
                               PBXFileReference and PBXBuildFile, should
                               set this to True.
    _encode_transforms: Used by _EncodeString to encode unprintable characters.
                        The index into this list is the ordinal of the
                        character to transform; each value is a string
                        used to represent the character in the output.  XCObject
                        provides an _encode_transforms list suitable for most
                        XCObject subclasses.
    _alternate_encode_transforms: Provided for subclasses that wish to use
                                  the alternate encoding rules.  Xcode seems
                                  to use these rules when printing objects in
                                  single-line format.  Subclasses that desire
                                  this behavior should set _encode_transforms
                                  to _alternate_encode_transforms.
  Attribues:
    id: The object's identifier, a 24-character uppercase hexadecimal string.
        Usually, objects being created should not set id until the entire
        project file structure is built.  At that point, UpdateIDs() should
        be called on the root object to assign deterministic values for id to
        each object in the tree.
    parent: The object's parent.  This is set by a parent XCObject when a child
            object is added to it.
    _properties: The object's property dictionary.  An object's properties are
                 described by its class' _schema variable.
  """

  _schema = {}
  _should_print_single_line = False

  # See _EncodeString.
  _encode_transforms = []
  i = 0
  while i < ord(" "):
    _encode_transforms.append("\\U%04x" % i)
    i = i + 1
  _encode_transforms[7] = "\\a"
  _encode_transforms[8] = "\\b"
  _encode_transforms[9] = "\\t"
  _encode_transforms[10] = "\\n"
  _encode_transforms[11] = "\\v"
  _encode_transforms[12] = "\\f"
  _encode_transforms[13] = "\\n"

  _alternate_encode_transforms = list(_encode_transforms)
  _alternate_encode_transforms[9] = chr(9)
  _alternate_encode_transforms[10] = chr(10)
  _alternate_encode_transforms[11] = chr(11)

  def __init__(self, properties=None, id=None, parent=None):
    self.id = id
    self.parent = parent
    self._properties = {}
    self._SetDefaultsFromSchema()
    self.UpdateProperties(properties)

  def Copy(self):
    """Make a copy of this object.

    The new object will have its own copy of lists and dicts.  Any XCObject
    objects owned by this object (marked "strong") will be copied in the
    new object, even those found in lists.  If this object has any weak
    references to other XCObjects, the same references are added to the new
    object without making a copy.
    """

    that = self.__class__(id=self.id, parent=self.parent)
    for key, value in self._properties.iteritems():
      is_strong = self._schema[key][2]

      if isinstance(value, XCObject):
        if is_strong:
          new_value = value.Copy()
          new_value.parent = that
          that._properties[key] = new_value
        else:
          that._properties[key] = value
      elif isinstance(value, str) or isinstance(value, int):
        that._properties[key] = value
      elif isinstance(value, list):
        if is_strong:
          # If is_strong is True, each element is an XCObject, so it's safe to
          # call Copy.
          that._properties[key] = []
          for item in value:
            new_item = item.Copy()
            new_item.parent = that
            that._properties[key].append(new_item)
        else:
          that._properties[key] = value[:]
      elif isinstance(value, dict):
        # dicts are never strong.
        if is_strong:
          raise TypeError, "Strong dict for key " + key + " in " + \
                           self.__class__.__name__
        else:
          that._properties[key] = value.copy()
      else:
        raise TypeError, "Unexpected type " + value.__class__.__name__ + \
                         " for key " + key + " in " + self.__class__.__name__

    return that

  def Name(self):
    """Return the name corresponding to an object.

    Not all objects necessarily need to be nameable, and not all that do have
    a "name" property.  Override as needed.
    """

    # If the schema indicates that "name" is required, try to access the
    # property even if it doesn't exist.  This will result in a KeyError
    # being raised for the property that should be present, which seems more
    # appropriate than NotImplementedError in this case.
    if "name" in self._properties or \
        ("name" in self._schema and self._schema["name"][3]):
      return self._properties["name"]

    raise NotImplementedError, \
          self.__class__.__name__ + " must implement Name"

  def Comment(self):
    """Return a comment string for the object.

    Most objects just use their name as the comment, but PBXProject uses
    different values.

    The returned comment is not escaped and does not have any comment marker
    strings applied to it.
    """

    return self.Name()

  def ComputeIDs(self, recursive=True, overwrite=True, hash=hashlib.sha1()):
    """Set "id" properties deterministically.

    An object's "id" property is set based on a hash of its class type and
    name, as well as the class type and name of all ancestor objects.  As
    such, it is only advisable to call ComputeIDs once an entire project file
    tree is built.

    If recursive is True, recurse into all descendant objects and update their
    hashes.

    If overwrite is True, any existing value set in the "id" property will be
    replaced.
    """

    def _HashUpdate(hash, data):
      """Update hash with data's length and contents.

      If the hash were updated only with the value of data, it would be
      possible for clowns to induce collisions by manipulating the names of
      their objects.  By adding the length, it's exceedingly less likely that
      ID collisions will be encountered, intentionally or not.
      """

      data_length = len(data)
      byte = (data_length & 0xff000000) >> 24
      hash.update(chr(byte))
      byte = (data_length & 0x00ff0000) >> 16
      hash.update(chr(byte))
      byte = (data_length & 0x0000ff00) >> 8
      hash.update(chr(byte))
      byte = data_length & 0x000000ff
      hash.update(chr(byte))
      hash.update(data)

    _HashUpdate(hash, self.__class__.__name__)
    name = self.Name()
    if name != None:
      _HashUpdate(hash, name)

    if recursive:
      for child in self.Children():
        child.ComputeIDs(recursive, overwrite, hash.copy())

    if overwrite or self.id == None:
      # TODO(mark): Xcode IDs are only 96 bits (24 hex characters), but a SHA-1
      # digest is 160 bits.  Instead of throwing out 64 bits of the digest, xor
      # them into the portion that gets used.  As-is, this should be fine,
      # because hashes are awesome and we're only after uniqueness here, not
      # security, but I hate computing perfectly good bits just to throw them
      # out.
      self.id = hash.hexdigest()[0:24].upper()

  def Children(self):
    """Returns a list of all of this object's owned (strong) children."""

    children = []
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong) = attributes[0:3]
      if is_strong and property in self._properties:
        if not is_list:
          children.append(self._properties[property])
        else:
          children.extend(self._properties[property])
    return children

  def Descendants(self):
    """Returns a list of all of this object's descendants, including this
    object.
    """

    children = self.Children()
    descendants = [self]
    for child in children:
      descendants.extend(child.Descendants())
    return descendants

  def PBXProjectAncestor(self):
    # The base case for recursion is defined at PBXProject.PBXProjectAncestor.
    if self.parent:
      return self.parent.PBXProjectAncestor()
    return None

  def _EncodeComment(self, comment):
    """Encodes a comment to be placed in the project file output, mimicing
    Xcode behavior.
    """

    # This mimics Xcode behavior by wrapping the comment in "/*" and "*/".  If
    # the string already contains a "*/", it is turned into "(*)/".  This keeps
    # the file writer from outputting something that would be treated as the
    # end of a comment in the middle of something intended to be entirely a
    # comment.

    return "/* " + comment.replace("*/", "(*)/") + " */"

  def _EncodeString(self, value):
    """Encodes a string to be placed in the project file output, mimicing
    Xcode behavior.
    """

    # Use quotation marks when any character outside of the range A-Z, a-z, 0-9,
    # $ (dollar sign), . (period), and _ (underscore) is present.  Also use
    # quotation marks to represent empty strings.
    #
    # Escape " (double-quote) and \ (backslash) by preceding them with a
    # backslash.
    #
    # Some characters below the printable ASCII range are encoded specially:
    #     7 ^G BEL is encoded as "\a"
    #     8 ^H BS  is encoded as "\b"
    #    11 ^K VT  is encoded as "\v"
    #    12 ^L NP  is encoded as "\f"
    #   127 ^? DEL is passed through as-is without escaping
    #  - In PBXFileReference and PBXBuildFile objects:
    #     9 ^I HT  is passed through as-is without escaping
    #    10 ^J NL  is passed through as-is without escaping
    #    13 ^M CR  is passed through as-is without escaping
    #  - In other objects:
    #     9 ^I HT  is encoded as "\t"
    #    10 ^J NL  is encoded as "\n"
    #    13 ^M CR  is encoded as "\n rendering it indistinguishable from
    #              10 ^J NL
    # All other nonprintable characters within the ASCII range (0 through 127
    # inclusive) are encoded as "\U001f" referring to the Unicode code point in
    # hexadecimal.  For example, character 14 (^N SO) is encoded as "\U000e".
    # Characters above the ASCII range are passed through to the output encoded
    # as UTF-8 without any escaping.  These mappings are contained in the
    # class' _encode_transforms list.

    if value != "" and StringContainsOnly(value,
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$._"):
      return value

    # Escape backslashes first, because subsequent replacements will introduce
    # more backslashes.
    encoded = value.replace('\\', '\\\\')
    encoded = encoded.replace('"', '\\"')

    i = 0
    while i < len(self._encode_transforms):
      encoded = encoded.replace(chr(i), self._encode_transforms[i])
      i = i + 1

    return '"' + encoded + '"'

  def _XCPrint(self, file, tabs, line):
    file.write("\t" * tabs + line)

  def _XCPrintableValue(self, tabs, value):
    """Returns a representation of value that may be printed in a project file,
    mimicing Xcode's behavior.

    _XCPrintableValue can handle str and int values, XCObjects (which are
    made printable by returning their id property), and list and dict objects
    composed of any of the above types.  When printing a list or dict, and
    _should_print_single_line is False, the tabs parameter is used to determine
    how much to indent the lines corresponding to the items in the list or
    dict.
    """

    printable = ""
    comment = None

    if self._should_print_single_line:
      sep = " "
      element_tabs = ""
      end_tabs = ""
    else:
      sep = "\n"
      element_tabs = "\t" * (tabs + 1)
      end_tabs = "\t" * tabs

    if isinstance(value, XCObject):
      printable += value.id
      comment = value.Comment()
    elif isinstance(value, str):
      printable += self._EncodeString(value)
    elif isinstance(value, int):
      printable += str(value)
    elif isinstance(value, list):
      printable = "(" + sep
      for item in value:
        printable += element_tabs + \
                     self._XCPrintableValue(tabs, item) + "," + sep
      printable += end_tabs + ")"
    elif isinstance(value, dict):
      printable = "{" + sep
      for item_key, item_value in sorted(value.iteritems()):
        printable += element_tabs + \
                     self._XCPrintableValue(tabs, item_key) + " = " + \
                     self._XCPrintableValue(tabs, item_value) + ";" + sep
      printable += end_tabs + "}"
    else:
      raise TypeError, "Can't make " + value.__class__.__name__ + " printable"

    if comment != None:
      printable += " " + self._EncodeComment(comment)

    return printable

  def _XCKVPrint(self, file, tabs, key, value):
    """Prints a key and value, members of an XCObject's _properties dictionary,
    to file.

    tabs is an int identifying the indentation level.  If the class'
    _should_print_single_line variable is True, tabs is ignored and the
    key-value pair will be followed by a space insead of a newline.
    """

    printable = ""

    if not self._should_print_single_line:
      printable = "\t" * tabs

    # Xcode usually prints remoteGlobalIDString values in PBXContainerItemProxy
    # objects without comments.  Sometimes it prints them with comments, but
    # the majority of the time, it doesn't.  To avoid unnecessary changes to
    # the project file after Xcode opens it, don't write comments for
    # remoteGlobalIDString.  This is a sucky hack and it would certainly be
    # cleaner to extend the schema to indicate whether or not a comment should
    # be printed, but since this is the only case where the problem occurs and
    # Xcode itself can't seem to make up its mind, the hack will suffice.
    #
    # Also see PBXContainerItemProxy._schema["remoteGlobalIDString"].
    if key == "remoteGlobalIDString" and isinstance(value, XCObject):
      value_to_print = value.id
    else:
      value_to_print = value

    printable += self._XCPrintableValue(tabs, key) + " = " + \
                 self._XCPrintableValue(tabs, value_to_print) + ";"
    if self._should_print_single_line:
      printable += " "
    else:
      printable += "\n"

    self._XCPrint(file, 0, printable)

  def Print(self, file=sys.stdout):
    """Prints a reprentation of this object to file, adhering to Xcode output
    formatting.
    """

    self.VerifyHasRequiredProperties()

    if self._should_print_single_line:
      # When printing an object in a single line, Xcode doesn't put any space
      # between the beginning of a dictionary (or presumably a list) and the
      # first contained item, so you wind up with snippets like
      #   ...CDEF = {isa = PBXFileReference; fileRef = 0123...
      # If it were me, I would have put a space in there after the opening
      # curly, but I guess this is just another one of those inconsistencies
      # between how Xcode prints PBXFileReference and PBXBuildFile objects as
      # compared to other objects.  Mimic Xcode's behavior here by using an
      # empty string for sep.
      sep = ""
      end_tabs = 0
    else:
      sep = "\n"
      end_tabs = 2

    # Start the object.  For example, "\t\tPBXProject = {\n".
    self._XCPrint(file, 2, self._XCPrintableValue(2, self) + " = {" + sep)

    # "isa" isn't in the _properties dictionary, it's an intrinsic property
    # of the class which the object belongs to.  Xcode always outputs "isa"
    # as the first element of an object dictionary.
    self._XCKVPrint(file, 3, "isa", self.__class__.__name__)

    # The remaining elements of an object dictionary are sorted alphabetically.
    for property, value in sorted(self._properties.iteritems()):
      self._XCKVPrint(file, 3, property, value)

    # End the object.
    self._XCPrint(file, end_tabs, "};\n")

  def UpdateProperties(self, properties, do_copy=False):
    """Merge the supplied properties into the _properties dictionary.

    The input properties must adhere to the class schema or a KeyError or
    TypeError exception will be raised.  If adding an object of an XCObject
    subclass and the schema indicates a strong relationship, the object's
    parent will be set to this object.

    If do_copy is True, then lists, dicts, strong-owned XCObjects, and
    strong-owned XCObjects in lists will be copied instead of having their
    references added.
    """

    if properties == None:
      return

    for property, value in properties.iteritems():
      # Make sure the property is in the schema.
      if not property in self._schema:
        raise KeyError, property + " not in " + self.__class__.__name__

      # Make sure the property conforms to the schema.
      (is_list, property_type, is_strong) = self._schema[property][0:3]
      if is_list:
        if value.__class__ != list:
          raise TypeError, \
                property + " of " + self.__class__.__name__ + \
                " must be list, not " + value.__class__.__name__
        for item in value:
          if not isinstance(item, property_type):
            raise TypeError, \
                  "item of " + property + " of " + self.__class__.__name__ + \
                  " must be " + property_type.__name__ + ", not " + \
                  item.__class__.__name__
      elif not isinstance(value, property_type):
        raise TypeError, \
              property + " of " + self.__class__.__name__ + " must be " + \
              property_type.__name__ + ", not " + value.__class__.__name__

      # Checks passed, perform the assignment.
      if do_copy:
        if isinstance(value, XCObject):
          if is_strong:
            self._properties[property] = value.Copy()
          else:
            self._properties[property] = value
        elif isinstance(value, str) or isinstance(value, int):
          self._properties[property] = value
        elif isinstance(value, list):
          if is_strong:
            # If is_strong is True, each element is an XCObject, so it's safe
            # to call Copy.
            self._properties[property] = []
            for item in value:
              self._properties[property].append(item.Copy())
          else:
            self._properties[property] = value[:]
        elif isinstance(value, dict):
          self._properties[property] = value.copy()
        else:
          raise TypeError, "Don't know how to copy a " + \
                           value.__class__.__name__ + " object for " + \
                           property + " in " + self.__class__.__name__
      else:
        self._properties[property] = value

      # Set up the child's back-reference to this object.  Don't use |value|
      # any more because it may not be right if do_copy is true.
      if is_strong:
        if not is_list:
          self._properties[property].parent = self
        else:
          for item in self._properties[property]:
            item.parent = self

  def HasProperty(self, key):
    return key in self._properties

  def GetProperty(self, key):
    return self._properties[key]

  def SetProperty(self, key, value):
    self.UpdateProperties({key: value})

  def DelProperty(self, key):
    if key in self._properties:
      del self._properties[key]

  def AppendProperty(self, key, value):
    # TODO(mark): Support ExtendProperty too (and make this call that)?

    # Schema validation.
    if not key in self._schema:
      raise KeyError, key + " not in " + self.__class__.__name__

    (is_list, property_type, is_strong) = self._schema[key][0:3]
    if not is_list:
      raise TypeError, key + " of " + self.__class__.__name__ + " must be list"
    if not isinstance(value, property_type):
      raise TypeError, "item of " + key + " of " + self.__class__.__name__ + \
                       " must be " + property_type.__name__ + ", not " + \
                       value.__class__.__name__

    # If the property doesn't exist yet, create a new empty list to receive the
    # item.
    if not key in self._properties:
      self._properties[key] = []

    # Set up the ownership link.
    if is_strong:
      value.parent = self

    # Store the item.
    self._properties[key].append(value)


  def VerifyHasRequiredProperties(self):
    """Ensure that all properties identified as required by the schema are
    set.
    """

    # TODO(mark): A stronger verification mechanism is needed.  Some
    # subclasses need to perform validation beyond what the schema can enforce.
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong, is_required) = attributes[0:4]
      if is_required and not property in self._properties:
        raise KeyError, self.__class__.__name__ + " requires " + property

  def _SetDefaultsFromSchema(self):
    """Assign object default values according to the schema.  This will not
    overwrite properties that have already been set."""

    defaults = {}
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong, is_required) = attributes[0:4]
      if is_required and len(attributes) >= 5 and \
          not property in self._properties:
        default = attributes[4]

        defaults[property] = default

    if len(defaults) > 0:
      # Use do_copy=True so that each new object gets its own copy of strong
      # objects, lists, and dicts.
      self.UpdateProperties(defaults, do_copy=True)


class XCHierarchicalElement(XCObject):
  """Abstract base for PBXGroup and PBXFileReference.  Not represented in a
  project file."""

  _schema = XCObject._schema.copy()
  _schema.update({
    "comments":       [0, str, 0, 0],
    "fileEncoding":   [0, str, 0, 0],
    "includeInIndex": [0, int, 0, 0],
    "indentWidth":    [0, int, 0, 0],
    "lineEnding":     [0, int, 0, 0],
    "sourceTree":     [0, str, 0, 1, "<group>"],
    "tabWidth":       [0, int, 0, 0],
    "usesTabs":       [0, int, 0, 0],
    "wrapsLines":     [0, int, 0, 0],
  })

  def Name(self):
    if "name" in self._properties:
      return self._properties["name"]
    elif "path" in self._properties:
      # TODO(mark): Verify that this is right.  Xcode might actually just take
      # the basename.
      return self._properties["path"]
    else:
      # This happens in the case of the root PBXGroup.
      return None


class PBXGroup(XCHierarchicalElement):
  _schema = XCHierarchicalElement._schema.copy()
  _schema.update({
    "children": [1, XCHierarchicalElement, 1, 1, []],
    "name":     [0, str,                   0, 0],
    "path":     [0, str,                   0, 0],
  })

  def GetChildByName(self, name):
    # TODO(mark): This should raise an error if more than one child is present
    # with the same name.
    if not "children" in self._properties:
      return None

    for child in self._properties["children"]:
      if child.Name() == name:
        return child

    return None


class PBXFileReference(XCHierarchicalElement):
  _schema = XCHierarchicalElement._schema.copy()
  _schema.update({
    "explicitFileType":  [0, str, 0, 0],
    "lastKnownFileType": [0, str, 0, 0],
    "name":              [0, str, 0, 0],
    "path":              [0, str, 0, 1],
  })

  # Weird output rules for PBXFileReference.
  _should_print_single_line = True
  _encode_transforms = XCHierarchicalElement._alternate_encode_transforms


class XCBuildConfiguration(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "baseConfigurationReference": [0, PBXFileReference, 0, 0],
    "buildSettings":              [0, dict, 0, 1, {}],
    "name":                       [0, str,  0, 1],
  })

  def HasBuildSetting(self, key):
    return key in self._properties["buildSettings"]

  def GetBuildSetting(self, key):
    return self._properties["buildSettings"][key]

  def SetBuildSetting(self, key, value):
    self._properties["buildSettings"][key] = value

  def DelBuildSetting(self, key):
    if key in self._properties["buildSettings"]:
      del self._properties["buildSettings"][key]


class XCConfigurationList(XCObject):
  # _configs is the default list of configurations.
  _configs = [ XCBuildConfiguration({"name": "Debug"}),
               XCBuildConfiguration({"name": "Release"}) ]

  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurations":           [1, XCBuildConfiguration, 1, 1, _configs],
    "defaultConfigurationIsVisible": [0, int,                  0, 1, 1],
    "defaultConfigurationName":      [0, str,                  0, 1, "Release"],
  })

  def Name(self):
    return "Build configuration list for " + \
           self.parent.__class__.__name__ + ' "' + self.parent.Name() + '"'

  def ConfigurationNamed(self, name):
    """Convenience accessor to obtain an XCBuildConfiguration by name."""
    for configuration in self._properties["buildConfigurations"]:
      if configuration._properties["name"] == name:
        return configuration

    raise KeyError, name

  def DefaultConfiguration(self):
    """Convenience accessor to obtain the default XCBuildConfiguration."""
    return self.ConfigurationNamed(self._properties["defaultConfigurationName"])

  def HasBuildSetting(self, key):
    """Determines the state of a build setting in all XCBuildConfiguration
    child objects.

    If all child objects have key in their build settings, and the value is the
    same in all child objects, returns 1.

    If no child objects have the key in their build settings, returns 0.

    If some, but not all, child objects have the key in their build settings,
    or if any children have different values for the key, returns -1.
    """

    has = None
    value = None
    for configuration in self._properties["buildConfigurations"]:
      configuration_has = configuration.HasBuildSetting(key)
      if has == None:
        has = configuration_has
      elif has != configuration_has:
        return -1

      if configuration_has:
        configuration_value = configuration.GetBuildSetting(key)
        if value == None:
          value = configuration_value
        elif value != configuration_value:
          return -1

    if not has:
      return 0

    return 1

  def GetBuildSetting(self, key):
    """Gets the build setting for key.

    All child XCConfiguration objects must have the same value set for the
    setting, or a ValueError will be raised.
    """

    value = None
    for configuration in self._properties["buildConfigurations"]:
      configuration_value = configuration.GetBuildSettings(key)
      if value == None:
        value = configuration_value
      else:
        if value != configuration_value:
          raise ValueError, "Variant values for " + key

    return value

  def SetBuildSetting(self, key, value):
    """Sets the build setting for key to value in all child
    XCBuildConfiguration objects.
    """

    for configuration in self._properties["buildConfigurations"]:
      configuration.SetBuildSetting(key, value)

  def DelBuildSetting(self, key):
    """Deletes the build setting key from all child XCBuildConfiguration
    objects.
    """

    for configuration in self._properties["buildConfigurations"]:
      configuration.DelBuildSetting(key)


class PBXBuildFile(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "fileRef": [0, PBXFileReference, 0, 1],
  })

  # Weird output rules for PBXBuildFile.
  _should_print_single_line = True
  _encode_transforms = XCObject._alternate_encode_transforms

  def Name(self):
    # Example: "main.cc in Sources"
    return self._properties["fileRef"].Name() + " in " + self.parent.Name()


class XCBuildPhase(XCObject):
  """Abstract base for build phase classes.  Not represented in a project
  file."""

  _schema = XCObject._schema.copy()
  _schema.update({
    "buildActionMask":                    [0, int,          0, 1, 0x7fffffff],
    "files":                              [1, PBXBuildFile, 1, 1, []],
    "runOnlyForDeploymentPostprocessing": [0, int,          0, 1, 0],
  })

  def AddFile(self, path):
    # TODO(mark): This is a quick hack.
    source_group = self.PBXProjectAncestor().SourceGroup()
    ref_props = {
      "lastKnownFileType": "sourcecode.cpp.cpp",
      "path":              path,
    }
    file_ref = PBXFileReference(ref_props)
    source_group.AppendProperty("children", file_ref)
    self.AppendProperty("files", PBXBuildFile({"fileRef": file_ref}))


class PBXHeadersBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Name(self):
    return "Headers"


class PBXSourcesBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Name(self):
    return "Sources"


class PBXFrameworksBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Name(self):
    return "Frameworks"


class PBXShellScriptBuildPhase(XCBuildPhase):
  _schema = XCBuildPhase._schema.copy()
  _schema.update({
    "inputPaths":       [1, str, 0, 1, []],
    "name":             [0, str, 0, 0],
    "outputPaths":      [1, str, 0, 1, []],
    "shellPath":        [0, str, 0, 1, "/bin/sh"],
    "shellScript":      [0, str, 0, 1],
    "showEnvVarsInLog": [0, int, 0, 0],
  })

  def Name(self):
    if "name" in self._properties:
      return self._properties["name"]

    return "ShellScript"


class PBXBuildRule(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "compilerSpec": [0, str, 0, 1],
    "filePatterns": [0, str, 0, 0],
    "fileType":     [0, str, 0, 1],
    "isEditable":   [0, int, 0, 1, 1],
    "outputFiles":  [1, str, 0, 1, []],
    "script":       [0, str, 0, 0],
  })


class PBXContainerItemProxy(XCObject):
  # When referencing an item in this project file, containerPortal is the
  # PBXProject root object of this project file.  When referencing an item in
  # another project file, containerPortal is a PBXFileReference identifying
  # the other project file.
  #
  # When serving as a proxy to an XCTarget (in this project file or another),
  # proxyType is 1.  When serving as a proxy to a PBXFileReference (in another
  # project file), proxyType is 2.  Type 2 is used for references to the
  # producs of the other project file's targets.
  #
  # Xcode is weird about remoteGlobalIDString.  Usually, it's printed without
  # a comment, indicating that it's tracked internally simply as a string, but
  # sometimes it's printed with a comment (usually when the object is initially
  # created), indicating that it's tracked as a project file object at least
  # sometimes.  This module always tracks it as an object, but contains a hack
  # to prevent it from printing the comment in the project file output.  See
  # _XCKVPrint.
  _schema = XCObject._schema.copy()
  _schema.update({
    "containerPortal":      [0, XCObject, 0, 1],
    "proxyType":            [0, int,      0, 1],
    "remoteGlobalIDString": [0, XCObject, 0, 1],
    "remoteInfo":           [0, str,      0, 1],
  })

  def Name(self):
    # Admittedly not the best name, but it's what Xcode uses.
    return self.__class__.__name__


class PBXTargetDependency(XCObject):
  # The "target" property accepts an XCTarget object, and obviously not
  # NoneType.  But XCTarget is defined below, so it can't be put into the
  # schema yet.  The definition of PBXTargetDependency can't be moved below
  # XCTarget because XCTarget's own schema references PBXTargetDependency.
  # Python doesn't deal well with this circular relationship, and doesn't have
  # a real way to do forward declarations.  To work around, the type of
  # the "target" property is reset below, after XCTarget is defined.
  _schema = XCObject._schema.copy()
  _schema.update({
    "target":      [0, None.__class__,        0, 1],
    "targetProxy": [0, PBXContainerItemProxy, 1, 1],
  })

  def Name(self):
    # Admittedly not the best name, but it's what Xcode uses.
    return self.__class__.__name__


class XCTarget(XCObject):
  # Setting a "name" property at instantiation may also affect "productName",
  # which may in turn affect the "PRODUCT_NAME" build setting in children of
  # "buildConfigurationList".  See __init__ below.
  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurationList": [0, XCConfigurationList, 1, 1,
                               XCConfigurationList()],
    "buildPhases":            [1, XCBuildPhase,        1, 1, []],
    "dependencies":           [1, PBXTargetDependency, 1, 1, []],
    "name":                   [0, str,                 0, 1],
    "productName":            [0, str,                 0, 1],
  })

  def __init__(self, properties=None, id=None, parent=None):
    # super
    XCObject.__init__(self, properties, id, parent)

    # Set up additional defaults not expressed in the schema.  If a "name"
    # property was supplied, set "productName" if it is not present.  Also set
    # the "PRODUCT_NAME" build setting in each configuration, but only if
    # the setting is not present in any build configuration.
    if "name" in self._properties:
      if not "productName" in self._properties:
        self.SetProperty("productName", self._properties["name"])

    if "productName" in self._properties:
      if "buildConfigurationList" in self._properties:
        configs = self._properties["buildConfigurationList"]
        if configs.HasBuildSetting("PRODUCT_NAME") == 0:
          configs.SetBuildSetting("PRODUCT_NAME",
                                  self._properties["productName"])

  def AddDependency(self, other):
    # TODO(mark): This is only correct for dependencies in the same project.
    pbxproject = self.PBXProjectAncestor()
    container = PBXContainerItemProxy({"containerPortal":      pbxproject,
                                       "proxyType":            1,
                                       "remoteGlobalIDString": other,
                                       "remoteInfo":           other.Name()})
    dependency = PBXTargetDependency({"target": other,
                                      "targetProxy": container})
    self.AppendProperty("dependencies", dependency)


# Redefine the type of the "target" property.  See PBXTargetDependency._schema
# above.
PBXTargetDependency._schema["target"][1] = XCTarget


class PBXNativeTarget(XCTarget):
  # buildPhases is overridden in the schema to be able to set defaults.
  #
  # NOTE: Contrary to most objects, it is advisable to set parent when
  # constructing PBXNativeTarget.  A parent of an XCTarget must be a PBXProject
  # object.  A parent reference is required for a PBXNativeTarget during
  # construction to be able to set up the target defaults for productReference,
  # because a PBXBuildFile object must be created for the target and it must
  # be added to the PBXProject's mainGroup hierarchy.
  _schema = XCTarget._schema.copy()
  _schema.update({
    "buildPhases":      [1, XCBuildPhase,     1, 1,
                         [PBXSourcesBuildPhase(), PBXFrameworksBuildPhase()]],
    "buildRules":       [1, PBXBuildRule,     1, 1, []],
    "productReference": [0, PBXFileReference, 0, 1],
    "productType":      [0, str,              0, 1],
  })

  _product_filetypes = {
    "com.apple.product-type.library.static": ["archive.ar", "lib", ".a"],
    "com.apple.product-type.tool":           ["compiled.mach-o.executable",
                                              "", ""],
  }

  def __init__(self, properties=None, id=None, parent=None):
    # super
    XCTarget.__init__(self, properties, id, parent)

    if "productName" in self._properties and \
       "productType" in self._properties and \
       not "productReference" in self._properties and \
       self._properties["productType"] in self._product_filetypes:
      products_group = None
      pbxproject = self.PBXProjectAncestor()
      if pbxproject != None:
        products_group = pbxproject.ProductsGroup()

      if products_group != None:
        (filetype, prefix, suffix) = \
            self._product_filetypes[self._properties["productType"]]

        ref_props = {
          "explicitFileType": filetype,
          "includeInIndex":   0,
          "path":             prefix + self._properties["productName"] + suffix,
          "sourceTree":       "BUILT_PRODUCTS_DIR",
        }
        file_ref = PBXFileReference(ref_props)
        products_group.AppendProperty("children", file_ref)
        self.SetProperty("productReference", file_ref)

  def GetBuildPhaseByType(self, type):
    # TODO(mark): Sanity-check that no more than one phase of type is present.
    # Some phases may be present in multiples in a well-formed project file,
    # but phases like PBXSourcesBuildPhase may only be present singly, and
    # this function is intended as an aid to GetBuildPhaseByType.
    if not "buildPhases" in self._properties:
      return None

    for phase in self._properties["buildPhases"]:
      if isinstance(phase, type):
        return phase

    return None

  def SourcesPhase(self):
    sources_phase = self.GetBuildPhaseByType(PBXSourcesBuildPhase)
    if sources_phase == None:
      sources_phase = PBXSourcesBuildPhase()
      self.AppendProperty("buildPhases", sources_phase)

    return sources_phase

  def FrameworksPhase(self):
    frameworks_phase = self.GetBuildPhaseByType(PBXFrameworksBuildPhase)
    if frameworks_phase == None:
      frameworks_phase = PBXFrameworksBuildPhase()
      self.AppendProperty("buildPhases", frameworks_phase)

    return frameworks_phase

  def AddDependency(self, other):
    # super
    XCTarget.AddDependency(self, other)
    static_library_type = "com.apple.product-type.library.static"
    if isinstance(other, PBXNativeTarget) and \
       "productType" in self._properties and \
       self._properties["productType"] != static_library_type and \
       "productType" in other._properties and \
       other._properties["productType"] == static_library_type:
      file_ref = other.GetProperty("productReference")
      self.FrameworksPhase().AppendProperty("files",
                                            PBXBuildFile({"fileRef": file_ref}))


class PBXProject(XCObject):
  """

  Attributes:
    name: The project name.  This should be set to the name of the project file
          without the .xcodeproj extension.  For example, the name attribute of
          "sample.xcodeproj" should be set to "sample".  name is a required
          attribute.
  """

  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurationList": [0, XCConfigurationList, 1, 1,
                               XCConfigurationList()],
    "compatibilityVersion":   [0, str,                 0, 1, "Xcode 3.1"],
    "hasScannedForEncodings": [0, int,                 0, 1, 1],
    "mainGroup":              [0, PBXGroup,            1, 1, PBXGroup()],
    "projectDirPath":         [0, str,                 0, 1, ""],
    "projectRoot":            [0, str,                 0, 1, ""],
    "targets":                [1, XCTarget,            1, 1, []],
  })

  def __init__(self, properties=None, id=None, parent=None, name=None):
    self.name = name
    # super
    return XCObject.__init__(self, properties, id, parent)

  def Name(self):
    return self.name

  def Comment(self):
    return "Project object"

  def PBXProjectAncestor(self):
    return self

  def _GroupByName(self, name):
    if not "mainGroup" in self._properties:
      self.SetProperty("mainGroup", PBXGroup())

    main_group = self._properties["mainGroup"]
    group = main_group.GetChildByName(name)
    if group == None:
      group = PBXGroup({"name": name})
      main_group.AppendProperty("children", group)

    return group

  def SourceGroup(self):
    return self._GroupByName("Source")

  def ProductsGroup(self):
    return self._GroupByName("Products")


class XCProjectFile(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "archiveVersion": [0, int,        0, 1, 1],
    "classes":        [0, dict,       0, 1, {}],
    "objectVersion":  [0, int,        0, 1, 45],
    "rootObject":     [0, PBXProject, 1, 1],
  })

  def ComputeIDs(self, recursive=True, overwrite=True, hash=hashlib.sha1()):
    # Although XCProjectFile is implemented here as an XCObject, it's not a
    # proper object in the Xcode sense, and it certainly doesn't have its own
    # ID.  Pass through an attempt to update IDs to the real root object.
    if recursive:
      self._properties["rootObject"].ComputeIDs(recursive, overwrite, hash)

  def Print(self, file=sys.stdout):
    self.VerifyHasRequiredProperties()

    # Add the special "objects" property, which will be caught and handled
    # separately during printing.  This structure allows a fairly standard
    # loop do the normal printing.
    self._properties["objects"] = {}
    self._XCPrint(file, 0, "// !$*UTF8*$!\n")
    if self._should_print_single_line:
      self._XCPrint(file, 0, "{ ")
    else:
      self._XCPrint(file, 0, "{\n")
    for property, value in sorted(self._properties.iteritems(),
                                  cmp=lambda x, y: cmp(x, y)):
      if property == "objects":
        self._PrintObjects(file)
      else:
        self._XCKVPrint(file, 1, property, value)
    self._XCPrint(file, 0, "}\n")
    del self._properties["objects"]

  def _PrintObjects(self, file):
    if self._should_print_single_line:
      self._XCPrint(file, 0, "objects = {")
    else:
      self._XCPrint(file, 1, "objects = {\n")

    objects_by_class = {}
    for object in self.Descendants():
      if object == self:
        continue
      class_name = object.__class__.__name__
      if not class_name in objects_by_class:
        objects_by_class[class_name] = []
      objects_by_class[class_name].append(object)

    for class_name in sorted(objects_by_class):
      self._XCPrint(file, 0, "\n")
      self._XCPrint(file, 0, "/* Begin " + class_name + " section */\n")
      for object in sorted(objects_by_class[class_name],
                           cmp=lambda x, y: cmp(x.id, y.id)):
        object.Print(file)
      self._XCPrint(file, 0, "/* End " + class_name + " section */\n")

    if self._should_print_single_line:
      self._XCPrint(file, 0, "}; ")
    else:
      self._XCPrint(file, 1, "};\n")


# TEST TEST TEST

def main():
  sf = PBXFileReference({"lastKnownFileType":"sourcecode.cpp.cpp", "path": "source.cc", "sourceTree": "SOURCE_ROOT"})
  sbf = PBXBuildFile({"fileRef":sf})

  tl = XCConfigurationList()
  tl.SetBuildSetting("PRODUCT_NAME", "targetty")
  ts = PBXSourcesBuildPhase({"files":[sbf]})
  pr = PBXFileReference({"explicitFileType":"archive.ar","includeInIndex":0,"path":"libtargetty.a","sourceTree":"BUILT_PRODUCTS_DIR"})
  t = PBXNativeTarget({"buildConfigurationList":tl,"buildPhases":[ts],"name":"targetty","productName":"targetty","productReference":pr,"productType":"com.apple.product-type.library.static"})

  sf2 = PBXFileReference({"lastKnownFileType":"sourcecode.cpp.cpp", "path": "source2.cc", "sourceTree": "SOURCE_ROOT"})
  sbf2 = PBXBuildFile({"fileRef":sf2})

  tl2 = XCConfigurationList()
  tl2.SetBuildSetting("PRODUCT_NAME", "dependent")
  ts2 = PBXSourcesBuildPhase({"files":[sbf2]})
  pr2 = PBXFileReference({"explicitFileType":"archive.ar","includeInIndex":0,"path":"libdependent.a","sourceTree":"BUILT_PRODUCTS_DIR"})

  depcip2to1 = PBXContainerItemProxy({"proxyType": 1, "remoteGlobalIDString": t, "remoteInfo": "targetty"})
  dep2to1 = PBXTargetDependency({"target": t, "targetProxy": depcip2to1})

  t2 = PBXNativeTarget({"buildConfigurationList":tl2,"buildPhases":[ts2],"dependencies":[dep2to1],"name":"dependent","productName":"dependent","productReference":pr2,"productType":"com.apple.product-type.library.static"})

  l = XCConfigurationList()
  g = PBXGroup({"children":[sf, pr, sf2, pr2]})

  o = PBXProject({"mainGroup":g, "buildConfigurationList":l, "targets":[t, t2]}, name="ssl")
  depcip2to1.UpdateProperties({"containerPortal":o})
  f = XCProjectFile({"rootObject":o})

  f.ComputeIDs()
  f.Print()

if __name__ == "__main__":
  main()
