#!/usr/bin/python

"""Xcode project file generator.

This module is both an Xcode project file generator and a documentation of the
Xcode project file format.  Knowledge of the project file format was gained
based on extensive experience with Xcode, and by making changes to projects in
Xcode.app and observing the resultant changes in the associated project files.

XCODE PROJECT FILES

The generator targets the file format as written by Xcode 3.1 (specifically,
3.1.2), but past experience has taught that the format has not changed
significantly in the past several years, and future versions of Xcode are able
to read older project files.

Xcode project files are "bundled": the project "file" from an end-user's
perspective is actually a directory with an ".xcodeproj" extension.  The
project file from this module's perspective is actually a file inside this
directory, always named "project.pbxproj".  This file contains a complete
description of the project and is all that is needed to use the xcodeproj.
Other files contained in the xcodeproj directory are simply used to store
per-user settings, such as the state of various UI elements in the Xcode
application.

The project.pbxproj file is a property list, stored in a format almost
identical to the NeXTstep property list format.  The file is able to carry
Unicode data, and is encoded in UTF-8.  The root element in the property list
is a dictionary that contains several properties of minimal interest, and two
properties of immense interest.  The most important property is a dictionary
named "objects".  The entire structure of the project is represented by the
children of this property.  The objects dictionary is keyed by unique 96-bit
values represented by 24 uppercase hexadecimal characters.  Each value in the
objects dictionary is itself a dictionary, describing an individual object.

Each object in the dictionary is a member of a class, which is identified by
the "isa" property of each object.  A variety of classes are represented in a
project file.  Objects can refer to other objects by ID, using the 24-character
hexadecimal object key.  A project's objects form a tree, with a root object
of class PBXProject at the root.  As an example, the PBXProject object serves
as parent to an XCConfigurationList object defining the build configurations
used in the project, a PBXGroup object serving as a container for all files
referenced in the project, and a list of target objects, each of which defines
a target in the project.  There are several different types of target object,
such as PBXNativeTarget and PBXAggregateTarget.  In this module, this
relationship is expressed by having each target type derive from an abstract
base named XCTarget.

The project.pbxproj file's root dictionary also contains a property, sibling to
the "objects" dictionary, named "rootObject".  The value of rootObject is a
24-character object key referring to the root PBXProject object in the
objects dictionary.

In Xcode, every file used as input to a target or produced as a final product
of a target must appear somewhere in the hierarchy rooted at the PBXGroup
object referenced by the PBXProject's mainGroup property.  A PBXGroup is
generally represented as a folder in the Xcode application.  PBXGroups can
contain other PBXGroups as well as PBXFileReferences, which are pointers to
actual files.

Each XCTarget contains a list of build phases, represented in this module by
the abstract base XCBuildPhase.  Examples of concrete XCBuildPhase derivations
are PBXSourcesBuildPhase and PBXFrameworksBuildPhase, which correspond to the
"Compile Sources" and "Link Binary With Libraries" phases displayed in the
Xcode application.  Files used as input to these phases (for example, source
files in the former case and libraries and frameworks in the latter) are
represented by PBXBuildFile objects, referenced by elements of "files" lists
in XCTarget objects.  Each PBXBuildFile object refers to a PBXBuildFile
object as a "weak" reference: it does not "own" the PBXBuildFile, which is
owned by the root object's mainGroup or a descendant group.  In most cases, the
layer of indirection between an XCBuildPhase and a PBXFileReference via a
PBXBuildFile appears extraneous, but there's actually one reason for this:
file-specific compiler flags are added to the PBXBuildFile object so as to
allow a single file to be a member of multiple targets while having distinct
compiler flags for each.  These flags can be modified in the Xcode applciation
in the "Build" tab of a File Info window.

When a project is open in the Xcode application, Xcode will rewrite it.  As
such, this module is careful to adhere to the formatting used by Xcode, to
avoid insignificant changes appearing in the file when it is used in the
Xcode application.  This will keep version control repositories happy, and
makes it possible to compare a project file used in Xcode to one generated by
this module to determine if any significant changes were made in the
application.

Xcode has its own way of assigning 24-character identifiers to each object,
which is not duplicated here.  Because the identifier only is only generated
once, when an object is created, and is then left unchanged, there is no need
to attempt to duplicate Xcode's behavior in this area.  The generator is free
to select any identifier, even at random, to refer to the objects it creates,
and Xcode will retain those identifiers and use them when subsequently
rewriting the project file.  However, the generator would choose new random
identifiers each time the project files are generated, leading to difficulties
comparing "used" project files to "pristine" ones produced by this module,
and causing the appearance of changes as every object identifier is changed
when updated projects are checked in to a version control repository.  To
mitigate this problem, this module chooses identifiers in a more deterministic
way, by hashing a description of each object as well as its parent and ancestor
objects.  This strategy should result in minimal "shift" in IDs as successive
generations of project files are produced.

THIS MODULE

This module introduces several classes, all derived from the XCObject class.
Nearly all of the "brains" are built into the XCObject class, which understands
how to create and modify objects, maintain the proper tree structure, compute
identifiers, and print objects.  For the most part, classes derived from
XCObject need only provide a _schema class object, a dictionary that
expresses what properties objects of the class may contain.

Given this structure, it's possible to build a minimal project file by creating
objects of the appropriate types and making the proper connections:

  config_list = XCConfigurationList()
  group = PBXGroup()
  project = PBXProject({"buildConfigurationList": config_list,
                        "mainGroup": group})

With the project object set up, it can be added to an XCProjectFile object.
XCProjectFile is a pseudo-class in the sense that it is a concrete XCObject
subclass that does not actually correspond to a class type found in a project
file.  Rather, it is used to represent the project file's root dictionary.
Printing an XCProjectFile will print the entire project file, including the
full "objects" dictionary.

  project_file = XCProjectFile({"rootObject": project})
  project_file.ComputeIDs()
  project_file.Print()
"""

import hashlib
import string
import sys


def StringContainsOnly(s, chars):
  """Returns True if s does not contain any character other than those in
  chars."""

  for c in s:
    if chars.find(c) == -1:
      return False
  return True


class XCObject(object):
  """The abstract base of all class types used in Xcode project files.

  Class variables:
    _schema: A dictionary defining the properties of this class.  The keys to
             _schema are string property keys as used in project files.  Values
             are a list of four or five elements:
             [ is_list, property_type, is_strong, is_required, default ]
             is_list: True if the property described is a list, as opposed
                      to a single element.
             property_type: The type to use as the value of the property,
                            or if is_list is True, the type to use for each
                            element of the value's list.  property_type must
                            be an XCObject subclass, or one of the built-in
                            types str, int, or dict.
             is_strong: If property_type is an XCObject subclass, is_strong
                        is True to assert that this class "owns," or serves
                        as parent, to the property value (or, if is_list is
                        True, values).  is_strong must be False if
                        property_type is not an XCObject subclass.
             is_required: True if the property is required for the class.
                          Note that is_required being True does not preclude
                          an empty string ("", in the case of property_type
                          str) or list ([], in the case of is_list True) from
                          being set for the property.
             default: Optional.  If is_requried is True, default may be set
                      to provide a default value for objects that do not supply
                      their own value.  If is_required is True and default
                      is not provided, users of the class must supply their own
                      value for the property.
             Note that although the values of the array are expressed in
             boolean terms, subclasses provide values as integers to conserve
             horizontal space.
    _should_print_single_line: False in XCObject.  Subclasses whose objects
                               should be written to the project file in the
                               alternate single-line format, such as
                               PBXFileReference and PBXBuildFile, should
                               set this to True.
    _encode_transforms: Used by _EncodeString to encode unprintable characters.
                        The index into this list is the ordinal of the
                        character to transform; each value is a string
                        used to represent the character in the output.  XCObject
                        provides an _encode_transforms list suitable for most
                        XCObject subclasses.
    _alternate_encode_transforms: Provided for subclasses that wish to use
                                  the alternate encoding rules.  Xcode seems
                                  to use these rules when printing objects in
                                  single-line format.  Subclasses that desire
                                  this behavior should set _encode_transforms
                                  to _alternate_encode_transforms.
  Attribues:
    id: The object's identifier, a 24-character uppercase hexadecimal string.
        Usually, objects being created should not set id until the entire
        project file structure is built.  At that point, UpdateIDs() should
        be called on the root object to assign deterministic values for id to
        each object in the tree.
    parent: The object's parent.  This is set by a parent XCObject when a child
            object is added to it.
    _properties: The object's property dictionary.  An object's properties are
                 described by its class' _schema variable.
  """

  _schema = {}
  _should_print_single_line = False

  # See _EncodeString.
  _encode_transforms = []
  i = 0
  while i < ord(" "):
    _encode_transforms.append("\\U%04x" % i)
    i = i + 1
  _encode_transforms[7] = "\\a"
  _encode_transforms[8] = "\\b"
  _encode_transforms[9] = "\\t"
  _encode_transforms[10] = "\\n"
  _encode_transforms[11] = "\\v"
  _encode_transforms[12] = "\\f"
  _encode_transforms[13] = "\\n"

  _alternate_encode_transforms = list(_encode_transforms)
  _alternate_encode_transforms[9] = chr(9)
  _alternate_encode_transforms[10] = chr(10)
  _alternate_encode_transforms[11] = chr(11)

  def __init__(self, properties=None, id=None):
    self.id = id
    self.parent = None
    self._properties = {}
    self._SetDefaultsFromSchema()
    self.UpdateProperties(properties)

  def Name(self):
    """Return the name corresponding to an object.

    Not all objects necessarily need to be nameable, and not all that do have
    a "name" property.  Override as needed.
    """

    if "name" in self._properties:
      return self._properties["name"]
    return None

  def Comment(self):
    # TODO(mark): Merge Name and Comment, we really just need Name.
    raise NotImplementedError, \
          self.__class__.__name__ + " must implement Comment"

  def ComputeIDs(self, recursive=True, overwrite=True, hash=hashlib.sha1()):
    """Set "id" properties deterministically.

    An object's "id" property is set based on a hash of its class type and
    name, as well as the class type and name of all ancestor objects.  As
    such, it is only advisable to call ComputeIDs once an entire project file
    tree is built.

    If recursive is True, recurse into all descendant objects and update their
    hashes.

    If overwrite is True, any existing value set in the "id" property will be
    replaced.
    """

    def _HashUpdate(hash, data):
      """Update hash with data's length and contents.

      If the hash were updated only with the value of data, it would be
      possible for clowns to induce collisions by manipulating the names of
      their objects.  By adding the length, it's exceedingly less likely that
      ID collisions will be encountered, intentionally or not.
      """

      data_length = len(data)
      byte = (data_length & 0xff000000) >> 24
      hash.update(chr(byte))
      byte = (data_length & 0x00ff0000) >> 16
      hash.update(chr(byte))
      byte = (data_length & 0x0000ff00) >> 8
      hash.update(chr(byte))
      byte = data_length & 0x000000ff
      hash.update(chr(byte))
      hash.update(data)

    _HashUpdate(hash, self.__class__.__name__)
    comment = self.Comment()
    if comment != None:
      _HashUpdate(hash, comment)

    if recursive:
      for child in self.Children():
        child.ComputeIDs(recursive, overwrite, hash.copy())

    if overwrite or self.id == None:
      # TODO(mark): Xcode IDs are only 96 bits (24 hex characters), but a SHA-1
      # digest is 160 bits.  Instead of throwing out 64 bits of the digest, xor
      # them into the portion that gets used.  As-is, this should be fine,
      # because hashes are awesome and we're only after uniqueness here, not
      # security, but I hate computing perfectly good bits just to throw them
      # out.
      self.id = hash.hexdigest()[0:24].upper()

  def Children(self):
    """Returns a list of all of this object's owned (strong) children."""

    children = []
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong) = attributes[0:3]
      if is_strong and property in self._properties:
        if not is_list:
          children.append(self._properties[property])
        else:
          children.extend(self._properties[property])
    return children

  def Descendants(self):
    """Returns a list of all of this object's descendants, including this
    object.
    """

    children = self.Children()
    descendants = [self]
    for child in children:
      descendants.extend(child.Descendants())
    return descendants

  def _EncodeComment(self, comment):
    """Encodes a comment to be placed in the project file output, mimicing
    Xcode behavior.
    """

    # This mimics Xcode behavior by wrapping the comment in "/*" and "*/".  If
    # the string already contains a "*/", it is turned into "(*)/".  This keeps
    # the file writer from outputting something that would be treated as the
    # end of a comment in the middle of something intended to be entirely a
    # comment.

    return "/* " + comment.replace("*/", "(*)/") + " */"

  def _EncodeString(self, value):
    """Encodes a string to be placed in the project file output, mimicing
    Xcode behavior.
    """

    # Use quotation marks when any character outside of the range A-Z, a-z, 0-9,
    # $ (dollar sign), . (period), and _ (underscore) is present.  Also use
    # quotation marks to represent empty strings.
    #
    # Escape " (double-quote) and \ (backslash) by preceding them with a
    # backslash.
    #
    # Some characters below the printable ASCII range are encoded specially:
    #     7 ^G BEL is encoded as "\a"
    #     8 ^H BS  is encoded as "\b"
    #    11 ^K VT  is encoded as "\v"
    #    12 ^L NP  is encoded as "\f"
    #   127 ^? DEL is passed through as-is without escaping
    #  - In PBXFileReference and PBXBuildFile objects:
    #     9 ^I HT  is passed through as-is without escaping
    #    10 ^J NL  is passed through as-is without escaping
    #    13 ^M CR  is passed through as-is without escaping
    #  - In other objects:
    #     9 ^I HT  is encoded as "\t"
    #    10 ^J NL  is encoded as "\n"
    #    13 ^M CR  is encoded as "\n rendering it indistinguishable from
    #              10 ^J NL
    # All other nonprintable characters within the ASCII range (0 through 127
    # inclusive) are encoded as "\U001f" referring to the Unicode code point in
    # hexadecimal.  For example, character 14 (^N SO) is encoded as "\U000e".
    # Characters above the ASCII range are passed through to the output encoded
    # as UTF-8 without any escaping.  These mappings are contained in the
    # class' _encode_transforms list.

    if value != "" and StringContainsOnly(value,
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$._"):
      return value

    # Escape backslashes first, because subsequent replacements will introduce
    # more backslashes.
    encoded = value.replace('\\', '\\\\')
    encoded = encoded.replace('"', '\\"')

    i = 0
    while i < len(self._encode_transforms):
      encoded = encoded.replace(chr(i), self._encode_transforms[i])
      i = i + 1

    return '"' + encoded + '"'

  def _XCPrint(self, file, tabs, line):
    file.write("\t" * tabs + line)

  def _XCPrintableValue(self, tabs, value):
    """Returns a representation of value that may be printed in a project file,
    mimicing Xcode's behavior.

    _XCPrintableValue can handle str and int values, XCObjects (which are
    made printable by returning their id property), and list and dict objects
    composed of any of the above types.  When printing a list or dict, and
    _should_print_single_line is False, the tabs parameter is used to determine
    how much to indent the lines corresponding to the items in the list or
    dict.
    """

    printable = ""
    comment = None

    if self._should_print_single_line:
      sep = " "
      element_tabs = ""
      end_tabs = ""
    else:
      sep = "\n"
      element_tabs = "\t" * (tabs + 1)
      end_tabs = "\t" * tabs

    if isinstance(value, XCObject):
      printable += value.id
      comment = value.Comment()
    elif isinstance(value, str):
      printable += self._EncodeString(value)
    elif isinstance(value, int):
      printable += str(value)
    elif isinstance(value, list):
      printable = "(" + sep
      for item in value:
        printable += element_tabs + \
                     self._XCPrintableValue(tabs, item) + "," + sep
      printable += end_tabs + ")"
    elif isinstance(value, dict):
      printable = "{" + sep
      for item_key, item_value in sorted(value.iteritems()):
        printable += element_tabs + \
                     self._XCPrintableValue(tabs, item_key) + " = " + \
                     self._XCPrintableValue(tabs, item_value) + ";" + sep
      printable += end_tabs + "}"
    else:
      raise TypeError, "Can't make " + value.__class__.__name__ + " printable"

    if comment != None:
      printable += " " + self._EncodeComment(comment)

    return printable

  def _XCKVPrint(self, file, tabs, key, value):
    """Prints a key and value, members of an XCObject's _properties dictionary,
    to file.

    tabs is an int identifying the indentation level.  If the class'
    _should_print_single_line variable is True, tabs is ignored and the
    key-value pair will be followed by a space insead of a newline.
    """

    printable = ""

    if not self._should_print_single_line:
      printable = "\t" * tabs

    printable += self._XCPrintableValue(tabs, key) + " = " + \
                 self._XCPrintableValue(tabs, value) + ";"
    if self._should_print_single_line:
      printable += " "
    else:
      printable += "\n"

    self._XCPrint(file, 0, printable)

  def Print(self, file=sys.stdout):
    """Prints a reprentation of this object to file, adhering to Xcode output
    formatting.
    """

    self.VerifyHasRequiredProperties()

    if self._should_print_single_line:
      # When printing an object in a single line, Xcode doesn't put any space
      # between the beginning of a dictionary (or presumably a list) and the
      # first contained item, so you wind up with snippets like
      #   ...CDEF = {isa = PBXFileReference; fileRef = 0123...
      # If it were me, I would have put a space in there after the opening
      # curly, but I guess this is just another one of those inconsistencies
      # between how Xcode prints PBXFileReference and PBXBuildFile objects as
      # compared to other objects.  Mimic Xcode's behavior here by using an
      # empty string for sep.
      sep = ""
      end_tabs = 0
    else:
      sep = "\n"
      end_tabs = 2

    # Start the object.  For example, "\t\tPBXProject = {\n".
    self._XCPrint(file, 2, self._XCPrintableValue(2, self) + " = {" + sep)

    # "isa" isn't in the _properties dictionary, it's an intrinsic property
    # of the class which the object belongs to.  Xcode always outputs "isa"
    # as the first element of an object dictionary.
    self._XCKVPrint(file, 3, "isa", self.__class__.__name__)

    # The remaining elements of an object dictionary are sorted alphabetically.
    for property, value in sorted(self._properties.iteritems()):
      self._XCKVPrint(file, 3, property, value)

    # End the object.
    self._XCPrint(file, end_tabs, "};\n")

  def UpdateProperties(self, properties):
    """Merge the supplied properties into the _properties dictionary.

    The input properties must adhere to the class schema or a KeyError or
    TypeError exception will be raised.  If adding an object of an XCObject
    subclass and the schema indicates a strong relationship, the object's
    parent will be set to this object.
    """

    if properties == None:
      return

    for property, value in properties.iteritems():
      # Make sure the property is in the schema.
      if not property in self._schema:
        raise KeyError, property + " not in " + self.__class__.__name__

      # Make sure the property conforms to the schema.
      (is_list, property_type, is_strong) = self._schema[property][0:3]
      if is_list:
        if value.__class__ != list:
          raise TypeError, \
                property + " of " + self.__class__.__name__ + " must be list"
        for item in value:
          if not isinstance(item, property_type):
            raise TypeError, \
                  "item of " + property + " of " + self.__class__.__name__ + \
                  " must be " + property_type.__name__
      elif not isinstance(value, property_type):
        raise TypeError, \
              property + " of " + self.__class__.__name__ + " must be " + \
              property_type.__name__

      # Checks passed, perform the assignment.
      self._properties[property] = value

      # Set up the child's back-reference to this object.
      if is_strong:
        if not is_list:
          value.parent = self
        else:
          for item in value:
            item.parent = self

  def VerifyHasRequiredProperties(self):
    """Ensure that all properties identified as required by the schema are
    set.
    """

    # TODO(mark): A stronger verification mechanism is needed.  Some
    # subclasses need to perform validation beyond what the schema can enforce.
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong, is_required) = attributes[0:4]
      if is_required and not property in self._properties:
        raise KeyError, self.__class__.__name__ + " requires " + property

  def _SetDefaultsFromSchema(self):
    """Assign object default values according to the schema.  This will not
    overwrite properties that have already been set."""

    defaults = {}
    for property, attributes in self._schema.iteritems():
      (is_list, property_type, is_strong, is_required) = attributes[0:4]
      if is_required and len(attributes) >= 5 and \
          not property in self._properties:
        default = attributes[4]

        # If the default is a list or dictionary, perform a shallow copy to
        # keep all default-users from getting the same lists and dicts.  Since
        # the copy isn't deep, and XCObject copying isn't currently supported,
        # there's no way to have XCObject subclasses in the schema defaults.
        # Practically, this means that defaults must currently be only of types
        # str or int, or dicts or lists that only contain these types (or,
        # more likely, are empty).
        if isinstance(default, list):
          default = default[:]
        elif isinstance(default, dict):
          default = default.copy()

        defaults[property] = default

    if len(defaults) > 0:
      self.UpdateProperties(defaults)


class XCHierarchicalElement(XCObject):
  """Abstract base for PBXGroup and PBXFileReference.  Not represented in a
  project file."""

  _schema = XCObject._schema.copy()
  _schema.update({
    "comments":       [0, str, 0, 0],
    "fileEncoding":   [0, str, 0, 0],
    "includeInIndex": [0, int, 0, 0],
    "indentWidth":    [0, int, 0, 0],
    "lineEnding":     [0, int, 0, 0],
    "sourceTree":     [0, str, 0, 1, "<group>"],
    "tabWidth":       [0, int, 0, 0],
    "usesTabs":       [0, int, 0, 0],
    "wrapsLines":     [0, int, 0, 0],
  })


class PBXGroup(XCHierarchicalElement):
  _schema = XCHierarchicalElement._schema.copy()
  _schema.update({
    "children": [1, XCHierarchicalElement, 1, 1, []],
    "name":     [0, str,                   0, 0],
    "path":     [0, str,                   0, 0],
  })

  def Comment(self):
    # TODO(mark): Use path if no name?  Share with PBXFileReference?
    return self.Name()


class PBXFileReference(XCHierarchicalElement):
  _schema = XCHierarchicalElement._schema.copy()
  _schema.update({
    "explicitFileType":  [0, str, 0, 0],
    "lastKnownFileType": [0, str, 0, 0],
    "name":              [0, str, 0, 0],
    "path":              [0, str, 0, 1],
  })

  # Weird output rules for PBXFileReference.
  _should_print_single_line = True
  _encode_transforms = XCHierarchicalElement._alternate_encode_transforms

  def Comment(self):
    if "path" in self._properties:
      return self._properties["path"]
    return self.Name()


class XCBuildConfiguration(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "baseConfigurationReference": [0, PBXFileReference, 0, 0],
    "buildSettings":              [0, dict, 0, 1, {}],
    "name":                       [0, str,  0, 1],
  })

  def Comment(self):
    return self.Name()

  def GetBuildSetting(self, key):
    return self._properties["buildSettings"][key]

  def SetBuildSetting(self, key, value):
    self._properties["buildSettings"][key] = value

  def DelBuildSetting(self, key):
    if key in self._properties["buildSettings"]:
      del self._properties["buildSettings"][key]


class XCConfigurationList(XCObject):
  # Note: buildConfigurations and defaultConfigurationName do have default
  # values.  See this class' override of _SetDefaultsFromSchema.
  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurations":           [1, XCBuildConfiguration, 1, 1],
    "defaultConfigurationIsVisible": [0, int,                  0, 1, 1],
    "defaultConfigurationName":      [0, str,                  0, 1],
  })

  def Comment(self):
    return "Build configuration list for " + \
           self.parent.__class__.__name__ + ' "' + self.parent.Name() + '"'

  def _SetDefaultsFromSchema(self):
    super(self.__class__, self)._SetDefaultsFromSchema()

    # The schema can't express a default contains objects unless it's extended
    # to make copies of the objects.  Otherwise, everyone accepting the
    # defaults would wind up with references to the same exact object.
    # Modifying the base _SetDefaultsFromSchema to copy objects is a
    # possibility, but since this case isn't encountered very often, an
    # override in this class will suffice.
    if not "buildConfigurations" in self._properties and \
       not "defaultConfigurationName" in self._properties:
      self.UpdateProperties(
          {
            "buildConfigurations": [ XCBuildConfiguration({"name": "Debug"}),
                                     XCBuildConfiguration({"name": "Release"}),
                                   ],
            "defaultConfigurationName": "Release",
          })

  def ConfigurationNamed(self, name):
    """Convenience accessor to obtain an XCBuildConfiguration by name."""
    for configuration in self._properties["buildConfigurations"]:
      if configuration._properties["name"] == name:
        return configuration

    raise KeyError, name

  def DefaultConfiguration(self):
    """Convenience accessor to obtain the default XCBuildConfiguration."""
    return self.ConfigurationNamed(self._properties["defaultConfigurationName"])

  def GetBuildSetting(self, key):
    """Gets the build setting for key.

    All child XCConfiguration objects must have the same value set for the
    setting, or a ValueError will be raised.
    """

    value = None
    for configuration in self._properties["buildConfigurations"]:
      configuration_value = configuration.GetBuildSettings(key)
      if value == None:
        value = configuration_value
      else:
        if value != configuration_value:
          raise ValueError, "Variant values for " + key

    return value

  def SetBuildSetting(self, key, value):
    """Sets the build setting for key to value in all child
    XCBuildConfiguration objects.
    """

    for configuration in self._properties["buildConfigurations"]:
      configuration.SetBuildSetting(key, value)

  def DelBuildSetting(self, key):
    """Deletes the build setting key from all child XCBuildConfiguration
    objects.
    """

    for configuration in self._properties["buildConfigurations"]:
      configuration.DelBuildSetting(key)


class PBXBuildFile(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "fileRef": [0, PBXFileReference, 0, 1],
  })

  # Weird output rules for PBXBuildFile.
  _should_print_single_line = True
  _encode_transforms = XCObject._alternate_encode_transforms

  def Comment(self):
    # Example: "main.cc in Sources"
    return self._properties["fileRef"].Comment() + " in " + \
           self.parent.Comment()


class XCBuildPhase(XCObject):
  """Abstract base for build phase classes.  Not represented in a project
  file."""

  _schema = XCObject._schema.copy()
  _schema.update({
    "buildActionMask":                    [0, int,          0, 1, 0x7fffffff],
    "files":                              [1, PBXBuildFile, 1, 1, []],
    "runOnlyForDeploymentPostprocessing": [0, int,          0, 1, 0],
  })


class PBXHeadersBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Comment(self):
    return "Headers"


class PBXSourcesBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Comment(self):
    return "Sources"


class PBXFrameworksBuildPhase(XCBuildPhase):
  # No additions to the schema relative to XCBuildPhase.

  def Comment(self):
    return "Frameworks"


class PBXShellScriptBuildPhase(XCBuildPhase):
  _schema = XCBuildPhase._schema.copy()
  _schema.update({
    "inputPaths":       [1, str, 0, 1, []],
    "name":             [0, str, 0, 0],
    "outputPaths":      [1, str, 0, 1, []],
    "shellPath":        [0, str, 0, 1, "/bin/sh"],
    "shellScript":      [0, str, 0, 1],
    "showEnvVarsInLog": [0, int, 0, 0],
  })

  def Comment(self):
    name = self.Name()
    if name != None:
      return name

    return "ShellScript"


# Provide forward declarations for PBXProject and XCTarget.  The problem here
# is that XCTarget depends on PBXTargetDependency, which depends on
# PBXContainerItemProxy, which in turn depends on XCTarget again.  The circle
# can't be broken, so advise Python of the existence of XCTarget before using
# it in PBXContainerItemProxy, in advance of defining XCTarget.  The same
# problem occurs with PBXProject, which depends on XCTarget and is itself
# depended on by PBXContainerItemProxy.
class PBXProject(XCObject):
  pass
class XCTarget(XCObject):
  pass

class PBXContainerItemProxy(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "containerPortal":      [0, PBXProject, 0, 1],
    "proxyType":            [0, int,        0, 1],  # TODO(mark): Default value?
    "remoteGlobalIDString": [0, XCTarget,   0, 1],  # TODO(mark): Just a str?
    "remoteInfo":           [0, str,        0, 1],
  })


class PBXTargetDependency(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "target":      [0, XCTarget,              0, 1],
    "targetProxy": [1, PBXContainerItemProxy, 1, 1],
  })


class PBXBuildRule(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "compilerSpec": [0, str, 0, 1],
    "filePatterns": [0, str, 0, 0],
    "fileType":     [0, str, 0, 1],
    "isEditable":   [0, int, 0, 1, 1],
    "outputFiles":  [1, str, 0, 1, []],
    "script":       [0, str, 0, 0],
  })


class XCTarget(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurationList": [0, XCConfigurationList, 1, 1],
    "buildPhases":            [1, XCBuildPhase,        1, 1, []],
    "dependencies":           [1, PBXTargetDependency, 1, 1, []],
    "name":                   [0, str,                 0, 1],
    "productName":            [0, str,                 0, 1],
  })

  def Comment(self):
    return self.Name()


class PBXNativeTarget(XCTarget):
  _schema = XCTarget._schema.copy()
  _schema.update({
    "buildRules":       [1, PBXBuildRule,     1, 1, []],
    "productReference": [0, PBXFileReference, 0, 1],
    "productType":      [0, str,              0, 1],
  })


class PBXProject(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "buildConfigurationList": [0, XCConfigurationList, 1, 1],
    "compatibilityVersion":   [0, str,                 0, 1, "Xcode 3.1"],
    "hasScannedForEncodings": [0, int,                 0, 1, 1],
    "mainGroup":              [0, PBXGroup,            1, 1],
    "projectDirPath":         [0, str,                 0, 1, ""],
    "projectRoot":            [0, str,                 0, 1, ""],
    "targets":                [1, XCTarget,            1, 1, []],
  })

  def Comment(self):
    return "Project object"

  def Name(self):
    return "FakeNameFixMe"


class XCProjectFile(XCObject):
  _schema = XCObject._schema.copy()
  _schema.update({
    "archiveVersion": [0, int,        0, 1, 1],
    "classes":        [0, dict,       0, 1, {}],
    "objectVersion":  [0, int,        0, 1, 45],
    "rootObject":     [0, PBXProject, 1, 1],
  })

  def ComputeIDs(self, recursive=True, overwrite=True, hash=hashlib.sha1()):
    # Although XCProjectFile is implemented here as an XCObject, it's not a
    # proper object in the Xcode sense, and it certainly doesn't have its own
    # ID.  Pass through an attempt to update IDs to the real root object.
    if recursive:
      self._properties["rootObject"].ComputeIDs(recursive, overwrite, hash)

  def Print(self, file=sys.stdout):
    self.VerifyHasRequiredProperties()

    # Add the special "objects" property, which will be caught and handled
    # separately during printing.  This structure allows a fairly standard
    # loop do the normal printing.
    self._properties["objects"] = {}
    self._XCPrint(file, 0, "// !$*UTF8*$!\n")
    if self._should_print_single_line:
      self._XCPrint(file, 0, "{ ")
    else:
      self._XCPrint(file, 0, "{\n")
    for property, value in sorted(self._properties.iteritems(),
                                  cmp=lambda x, y: cmp(x, y)):
      if property == "objects":
        self._PrintObjects(file)
      else:
        self._XCKVPrint(file, 1, property, value)
    self._XCPrint(file, 0, "}\n")
    del self._properties["objects"]

  def _PrintObjects(self, file):
    if self._should_print_single_line:
      self._XCPrint(file, 0, "objects = {")
    else:
      self._XCPrint(file, 1, "objects = {\n")

    objects_by_class = {}
    for object in self.Descendants():
      if object == self:
        continue
      class_name = object.__class__.__name__
      if not class_name in objects_by_class:
        objects_by_class[class_name] = []
      objects_by_class[class_name].append(object)

    for class_name in sorted(objects_by_class):
      self._XCPrint(file, 0, "\n")
      self._XCPrint(file, 0, "/* Begin " + class_name + " section */\n")
      for object in sorted(objects_by_class[class_name],
                           cmp=lambda x, y: cmp(x.id, y.id)):
        object.Print(file)
      self._XCPrint(file, 0, "/* End " + class_name + " section */\n")

    if self._should_print_single_line:
      self._XCPrint(file, 0, "}; ")
    else:
      self._XCPrint(file, 1, "};\n")


# TEST TEST TEST

sf = PBXFileReference({"lastKnownFileType":"sourcecode.cpp.cpp", "path": "source.cc", "sourceTree": "SOURCE_ROOT"})
sbf = PBXBuildFile({"fileRef":sf})

tl = XCConfigurationList()
tl.SetBuildSetting("PRODUCT_NAME", "targetty")
ts = PBXSourcesBuildPhase({"files":[sbf]})
pr = PBXFileReference({"explicitFileType":"archive.ar","includeInIndex":0,"path":"libtargetty.a","sourceTree":"BUILT_PRODUCTS_DIR"})
t = PBXNativeTarget({"buildConfigurationList":tl,"buildPhases":[ts],"name":"targetty","productName":"targetty","productReference":pr,"productType":"com.apple.product-type.library.static"})

l = XCConfigurationList()
g = PBXGroup({"children":[sf, pr]})

o = PBXProject({"mainGroup":g, "buildConfigurationList":l, "targets":[t]})
f = XCProjectFile({"rootObject":o})

f.ComputeIDs()
f.Print()
